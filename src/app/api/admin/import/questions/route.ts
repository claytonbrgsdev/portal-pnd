import { NextRequest, NextResponse } from 'next/server'
import { createClient as createServerClient } from '@/utils/supabase/server'
import { createClient } from '@supabase/supabase-js'

type InputKnowledgeObject = { codigo: string; descricao: string }

type InputJsonQuestion = {
  metadados: {
    questao_numero?: number
    componente?: string
    ano_exame?: number
    dificuldade?: string
    competencia_descricao?: string
    habilidade_codigo?: string
    habilidade_descricao?: string
    informacao_complementar?: string
    objetos_do_conhecimento?: InputKnowledgeObject[]
  }
  elemento_textual_1?: { titulo?: string | null; conteudo?: string | null; fonte?: { referencia?: string | null } }
  elemento_textual_2?: { titulo?: string | null; conteudo?: string | null }
  comando_questao: { texto: string }
  julgamento_das_opcoes: Array<{ id: 'A'|'B'|'C'|'D'; enunciado: string; gabarito: 'CORRETA' | 'ERRADA'; justificativa?: string }>
}

function toQuestionAndMetadata(input: InputJsonQuestion) {
  const options = new Map(input.julgamento_das_opcoes.map(o => [o.id, o]))
  const correct = input.julgamento_das_opcoes.find(o => o.gabarito === 'CORRETA')

  const question = {
    // id: generated by database if default exists; else we will set later from insert result
    correct_letter: correct?.id ?? null,
    prompt: input.comando_questao?.texto ?? '',
    alt_a_text: options.get('A')?.enunciado ?? '',
    alt_b_text: options.get('B')?.enunciado ?? '',
    alt_c_text: options.get('C')?.enunciado ?? '',
    alt_d_text: options.get('D')?.enunciado ?? '',
    alt_a_justification: options.get('A')?.justificativa ?? '',
    alt_b_justification: options.get('B')?.justificativa ?? '',
    alt_c_justification: options.get('C')?.justificativa ?? '',
    alt_d_justification: options.get('D')?.justificativa ?? '',
    component: input.metadados?.componente ?? '',
    difficulty: input.metadados?.dificuldade ?? '',
    natural_key: input.metadados?.ano_exame && input.metadados?.questao_numero
      ? `${input.metadados.ano_exame}-${input.metadados.questao_numero}`
      : null,
    text1_title: input.elemento_textual_1?.titulo ?? null,
    text1_content: input.elemento_textual_1?.conteudo ?? null,
    text1_source: input.elemento_textual_1?.fonte?.referencia ?? null,
    text2_title: input.elemento_textual_2?.titulo ?? null,
    text2_content: input.elemento_textual_2?.conteudo ?? null,
    year: input.metadados?.ano_exame ?? null,
  }

  const metadata = {
    // question_id filled after we insert question
    competency_desc: input.metadados?.competencia_descricao ?? null,
    skill_code: input.metadados?.habilidade_codigo ?? null,
    skill_desc: input.metadados?.habilidade_descricao ?? null,
    extra_info: input.metadados?.informacao_complementar ?? null,
    knowledge_objects: input.metadados?.objetos_do_conhecimento ?? null,
  }

  return { question, metadata }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerClient()
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })
    }
    const role = session.user.user_metadata?.user_role
    if (role !== 'admin') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    const payload = await request.json()
    const items: InputJsonQuestion[] = Array.isArray(payload) ? payload : [payload]
    if (items.length === 0) {
      return NextResponse.json({ error: 'No items to import' }, { status: 400 })
    }

    const adminClient = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      { auth: { autoRefreshToken: false, persistSession: false } }
    )

    const results: Array<{ index: number; question_id?: string; error?: string }> = []

    for (let i = 0; i < items.length; i++) {
      const { question, metadata } = toQuestionAndMetadata(items[i])

      // Insert question first
      const { data: inserted, error: qErr } = await adminClient
        .from('questions')
        .insert(question)
        .select('id')
        .single()

      if (qErr || !inserted?.id) {
        results.push({ index: i, error: qErr?.message || 'Failed to insert question' })
        continue
      }

      const questionId = inserted.id as string

      const { error: mErr } = await adminClient
        .from('question_metadata')
        .insert({ ...metadata, question_id: questionId })

      if (mErr) {
        results.push({ index: i, question_id: questionId, error: mErr.message })
        continue
      }

      results.push({ index: i, question_id: questionId })
    }

    // Log admin action summary
    await supabase.from('admin_actions').insert({
      admin_id: session.user.id,
      action: 'questions_import',
      payload: { total: items.length, imported: results.filter(r => !r.error).length, errors: results.filter(r => r.error) }
    })

    return NextResponse.json({ success: true, results })
  } catch (err) {
    console.error('Import questions error:', err)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}


